#include "Engine.hpp"
#include "risk_models.pb.h" // Generated by CMake

#include <vector>
#include <random>
#include <cmath>
#include <algorithm>
#include <stdexcept>

namespace RiskEngine {

    std::vector<double> Simulator::SimulateGBM(double S0, double r, double sigma, 
        double T, int num_paths) 
    {
        std::vector<double> paths(num_paths);
        std::mt19937 gen(42); // Fixed seed for reproducibility
        std::normal_distribution <double> d(0, 1);

        double drift = (r - 0.5 * sigma * sigma) * T;
        double vol_sqrt_T = sigma * std::sqrt(T);

        for (int i = 0; i < num_paths; ++i) {
            double Z = d(gen);
            paths[i] = S0 * std::exp(drift + vol_sqrt_T * Z);
        }
        return paths;
    }

	// ---Non uniform time-grid generator --- helper function
    static std::vector<double> GenerateNonUniformTimeGrid(double T) {
        std::vector<double> times;
        if (T <= 0.0) {
            times.push_back(0.0);
            return times;
         }

        // Fine resolution for first year (monthly), medium for years 1-5 (quarterly),
        // coarse for remaining years (yearly) — truncated at T
        // Always include time 0 and T.
        times.push_back(0.0);
		double end1 = std::min(T, 1.0);
        double dt_month = 1.0 / 12.0;
        for (double t = dt_month; t < end1 + 1e-12; t += dt_month)
            if (t < T){
                times.push_back(t);
			}

        double start2 = 1.0;
        double end2 = std::min(T, 5.0);
		double dt_quarter = 1.0 / 4.0;
        for (double t = start2 + dt_month; t < end2 + 1e-12; t += dt_quarter)
            if (t < T){
				times.push_back(t);
                }
        double start3 = 5.0;
        double dt_year = 1.0;
        for (double t = std::max(start3, start2); t < T ; t += dt_year)
			if (t < T) times.push_back(t);
        
        // Ensure T is included
        times.push_back(T);
        std::sort(times.begin(), times.end());
		times.erase(std::unique(times.begin(), times.end()), times.end());
        
		return times;

    }

    // --- Helper: standard normal CDF using std::erf ---
    static double NormalCdf(double x) {
        return 0.5 * (1.0 + std::erf(x / std::sqrt(2.0)));
    }

    // --- Helper: Black-Scholes call price (price at time t for remaining tau) ---
    static double BlackScholesCall(double S, double K, double r, double sigma, double tau) {
        if (tau <= 0.0) {
            // If zero remaining maturity, payoff
            return std::max(S - K, 0.0);
        }
        if (sigma <= 0.0) {
            // In zero vol limit, forward price discounted
            double forward = S * std::exp(r * tau);
            double payoff = std::max(forward - K, 0.0);
            return std::exp(-r * tau) * payoff;
        }
        double sqrt_tau = std::sqrt(tau);
        double d1 = (std::log(S / K) + (r + 0.5 * sigma * sigma) * tau) / (sigma * sqrt_tau);
        double d2 = d1 - sigma * sqrt_tau;
        double Nd1 = NormalCdf(d1);
        double Nd2 = NormalCdf(d2);
        return S * Nd1 - K * std::exp(-r * tau) * Nd2;
    }

    // --- Helper: simulate full paths at given time points (paths x times) ---
    static std::vector<std::vector<double>> SimulateGBMPaths(double S0, double r, double sigma,
                                                             const std::vector<double>& times,
                                                             int num_paths) {
        int n_times = static_cast<int>(times.size());
        std::vector<std::vector<double>> matrix;
        matrix.assign(num_paths, std::vector<double>(n_times, 0.0));

        // Use fixed seed for reproducibility (change if you want randomness across runs)
        std::mt19937 gen(42);
        std::normal_distribution<> nd(0.0, 1.0);

        for (int p = 0; p < num_paths; ++p) {
            double S_prev = S0;
            double t_prev = 0.0;
            matrix[p][0] = S0; // at time 0

            for (int ti = 1; ti < n_times; ++ti) {
                double t = times[ti];
                double dt = t - t_prev;
                if (dt <= 0.0) {
                    matrix[p][ti] = S_prev;
                    t_prev = t;
                    continue;
                }

                double drift = (r - 0.5 * sigma * sigma) * dt;
                double vol_sqrt_dt = sigma * std::sqrt(dt);
                double Z = nd(gen);
                double S_t = S_prev * std::exp(drift + vol_sqrt_dt * Z);

                matrix[p][ti] = S_t;
                // step forward
                S_prev = S_t;
                t_prev = t;
            }
        }
        return matrix;
    }

    void Pricer::CalculateRisk(const std::string& serialized_request, std::string& serialized_response) {
        // 1. Deserialize
        risk_models::TradeRequest request;
        if (!request.ParseFromString(serialized_request)) {
            throw std::runtime_error("Failed to parse Proto");
        }

        // 2. Build non-uniform time grid up to maturity (cap at 30 years if needed)
        double T = std::min(request.maturity(), 30.0); // make sure not more than 30y
        auto times = GenerateNonUniformTimeGrid(T);

        // 3. Simulate full paths at the grid times
        int paths = 1000;
        auto path_matrix = SimulateGBMPaths(
            request.spot_price(), request.risk_free_rate(),
            request.volatility(), times, paths
        );

        // 4. Build MtM matrix: for each simulated S(t) compute option price at that time
        int n_times = static_cast<int>(times.size());
        // mtm_matrix not stored fully here to save memory; we'll compute exposures on the fly
        std::vector<double> exposure_profile(n_times, 0.0);

        for (int ti = 0; ti < n_times; ++ti) {
            double t = times[ti];
            double tau = std::max(0.0, T - t); // remaining maturity for pricing
            double sum_positive = 0.0;

            for (int p = 0; p < paths; ++p) {
                double S_t = path_matrix[p][ti];
                double price = BlackScholesCall(S_t, request.strike(), request.risk_free_rate(), request.volatility(), tau);
                // exposure uses positive MtM only (for a call, price >= 0 already)
                double pos = price > 0.0 ? price : 0.0;
                sum_positive += pos;
            }
            exposure_profile[ti] = sum_positive / static_cast<double>(paths);
        }

        // 5. Present value and PFE: compute PV as average discounted payoff (same as before)
        //    and keep pfe_95 from the distribution of discounted payoffs at maturity.
        std::vector<double> discounted_payoffs;
        discounted_payoffs.reserve(paths);
        double discount = std::exp(-request.risk_free_rate() * T);
        for (int p = 0; p < paths; ++p) {
            double S_T = path_matrix[p].back();
            double payoff = std::max(S_T - request.strike(), 0.0);
            discounted_payoffs.push_back(payoff * discount);
        }
        double total_payoff = std::accumulate(discounted_payoffs.begin(), discounted_payoffs.end(), 0.0);
        double pv = total_payoff / static_cast<double>(paths);

        std::sort(discounted_payoffs.begin(), discounted_payoffs.end());
        double pfe = discounted_payoffs[std::min(static_cast<int>(discounted_payoffs.size()) - 1,
            static_cast<int>(0.95 * discounted_payoffs.size()))];

        // 6. Serialize Response
        risk_models::ValuationResult result;
        result.set_trade_id(request.trade_id());
        result.set_counterparty_id(request.counterparty_id());
        result.set_present_value(pv);
        result.set_pfe_95(pfe);

        // NOTE: the proto must be extended to hold the time grid and exposure profile:
        //   repeated double mtm_times = X;
        //   repeated double exposure_profile = Y;
        // If you updated the proto accordingly, the generated API will provide:
        //   result.add_mtm_times(value) and result.add_exposure_profile(value)
        for (double tt : times) {
            result.add_mtm_times(tt);
        }
        for (double e : exposure_profile) {
            result.add_exposure_profile(e);
        }

        result.SerializeToString(&serialized_response);
    }
}